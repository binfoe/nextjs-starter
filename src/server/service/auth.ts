import NextAuth, { NextAuthConfig } from 'next-auth';
import { PrismaAdapter } from '@auth/prisma-adapter';
import CredentialsProvider from 'next-auth/providers/credentials';
import { OAuth2Client } from 'google-auth-library';

import Google from 'next-auth/providers/google';
import Github from 'next-auth/providers/github';
import { prisma } from './db';
import { getEnv } from '@/common/env';

// This is an instance of a google client that we need to ask google informations about the user
const googleAuthClient = new OAuth2Client(getEnv('NEXT_PUBLIC_GOOGLE_CLIENT_ID'));
const adapter = PrismaAdapter(prisma);

export const config = {
  pages: {
    signIn: '/login',
    error: '/login',
  },
  adapter,
  providers: [
    Google({
      clientId: getEnv('NEXT_PUBLIC_GOOGLE_CLIENT_ID'),
      clientSecret: getEnv('GOOGLE_CLIENT_SECRET'),
    }),
    Github({
      clientId: getEnv('GITHUB_CLIENT_ID'),
      clientSecret: getEnv('GITHUB_CLIENT_SECRET'),
    }),
    // https://www.ramielcreations.com/next-auth-google-one-tap
    CredentialsProvider({
      // The id of this credential provider. It's important to give an id because, in frontend we don't want to
      // show anything about this provider in a normal login flow
      id: 'googleonetap',
      // A readable name
      name: 'google-one-tap',

      // This field define what parameter we expect from the FE and what's its name. In this case "credential"
      // This field will contain the token generated by google
      credentials: {
        credential: { type: 'text' },
      },
      // This where all the logic goes
      authorize: async (credentials) => {
        // The token given by google and provided from the frontend
        const token = credentials.credential as string;
        // We use the google library to exchange the token with some information about the user
        const ticket = await googleAuthClient.verifyIdToken({
          // The token received from the interface
          idToken: token,
          // This is the google ID of your application
          audience: getEnv('GOOGLE_CLIENT_ID'),
        });
        const payload = ticket.getPayload(); // This is the user

        if (!payload) {
          throw new Error('Cannot extract payload from signin token');
        }

        // If the request went well, we received all this info from Google.
        const { email, sub, given_name, family_name, email_verified, picture: image } = payload;

        // If for some reason the email is not provided, we cannot login the user with this method
        if (!email) {
          throw new Error('Email not available');
        }

        if (
          !adapter.getUserByEmail ||
          !adapter.createUser ||
          !adapter.getUserByAccount ||
          !adapter.linkAccount
        ) {
          throw new Error('bad adapter');
        }
        // Let's check on our DB if the user exists
        let user = await adapter.getUserByEmail(email);

        // If there's no user, we need to create it
        if (!user) {
          user = await adapter.createUser({
            name: [given_name, family_name].join(' '),
            email,
            image,
            emailVerified: email_verified ? new Date() : null,
          });
        }

        // Let's also retrieve any account for the user from the DB, if any
        const account =
          user && (await adapter.getUserByAccount({ provider: 'google', providerAccountId: sub }));

        // In case the account is not yet present on our DB, we want to create one and link to the user
        if (!account && user) {
          await adapter.linkAccount({
            type: 'oauth',
            userId: user.id,
            provider: 'google',
            providerAccountId: sub,
            // accessToken: null,
            // accessTokenExpires: null,
            // refresh_token: null,
          });
        }
        // We can finally returned the retrieved or created user
        return user;
      },
    }),
  ],

  callbacks: {
    // authorized({ request, auth }) {
    //   const { pathname } = request.nextUrl;
    //   if (pathname === '/middleware-example') return !!auth;
    //   return true;
    // },
    async signIn({ account, profile }) {
      if (!account) return false;
      if (account.provider === 'google' && !profile?.email_verified) {
        return false;
      }
      return true;
    },
  },
} as NextAuthConfig;

export const { handlers, auth, signIn, signOut } = NextAuth(config);
